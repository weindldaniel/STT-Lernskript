\newpage
\subsection{AWL}

\subsubsection{Grundprinzip}

Die Anweisungsliste (AWL, engl. Instruction List – IL) ist eine textuelle
Programmiersprache der IEC~61131-3.
Sie ist maschinennah aufgebaut und lehnt sich konzeptionell an die
Assemblerprogrammierung an.

AWL arbeitet nach dem Prinzip einer \textbf{Ein-Adress-Maschine}.
Alle Operationen erfolgen über ein zentrales Rechenregister,
den sogenannten \textbf{Akkumulator (AKKU)}.

\subsubsection{Ein-Adress-Maschine}

Bei einer Ein-Adress-Maschine besitzt jede Rechenoperation genau einen expliziten
Operanden.
Der zweite Operand ist implizit der Inhalt des Akkumulators.

\medskip
Arbeitsweise:
\begin{enumerate}
    \item Ein Wert wird in den Akku geladen
    \item Der Akku wird mit weiteren Operanden verarbeitet
    \item Das Ergebnis wird aus dem Akku gespeichert
\end{enumerate}

\paragraph{Beispiel}
Berechnung:
\[
a = (x + y) \cdot c
\]

AWL-Code:
\begin{verbatim}
LD   x
ADD  y
MUL  c
ST   a
\end{verbatim}

\subsubsection{Aufbau eines AWL-Programms}

Ein AWL-Programm besteht aus einer Folge von Anweisungen.
Jede Anweisung steht in einer eigenen Zeile und besteht aus:
\begin{itemize}
    \item einem Operator
    \item optional einem oder mehreren Operanden
\end{itemize}

Vor einer Anweisung kann optional eine Sprungmarke (Label) stehen.

\subsubsection{Akkumulator}

Der Akkumulator speichert stets das Ergebnis der letzten Operation.
Jede neue Operation überschreibt den vorherigen Inhalt des Akkus.

Der Datentyp des Akkumulators wird durch die ausgeführte Operation bestimmt.
Daher müssen die Datentypen aufeinanderfolgender Anweisungen kompatibel sein.

\medskip
\textbf{Wichtig:}  
Ein falscher Datentyp im Akku führt zu Laufzeit- oder Compilerfehlern.

\subsubsection{Operatoren und Operanden}

\paragraph{Operatoren}
Operatoren beschreiben die auszuführende Operation.
Typische Operatoren sind:
\begin{itemize}
    \item LD (Load)
    \item ST (Store)
    \item AND, OR, XOR
    \item ADD, SUB, MUL, DIV
    \item EQ, GT, LT
\end{itemize}

\paragraph{Operanden}
Operanden können sein:
\begin{itemize}
    \item Variablen
    \item Literale
    \item Instanznamen von Funktionsbausteinen
\end{itemize}

\subsubsection{Modifier in AWL}

Operatoren können durch sogenannte Modifier erweitert werden.

\paragraph{Negationsmodifier N}
Der Modifier \texttt{N} negiert den Operanden vor der Ausführung der Operation.

\begin{verbatim}
LD   Var1
ANDN Var2
ST   Var3
\end{verbatim}

Dies entspricht logisch:
\[
Var3 := Var1 \land \lnot Var2
\]

\subsubsection{Klammerung und Schachtelung}

AWL erlaubt die Klammerung von Anweisungsfolgen.
Der geklammerte Ausdruck wird zuerst ausgewertet und anschließend
mit dem vorherigen Akkumulatorwert verknüpft.

\begin{verbatim}
LD   Var1
AND(
     Var2
     OR Var3
   )
ST   Var4
\end{verbatim}

Ergebnis:
\[
Var4 := Var1 \land (Var2 \lor Var3)
\]

Klammern können geschachtelt werden, müssen jedoch stets
einen gültigen Datentyp liefern.

\subsubsection{Bedingte Ausführung}

AWL ermöglicht die bedingte Ausführung von Anweisungen.
Hierzu wird das aktuelle Ergebnis im Akku als Bedingung verwendet.

\paragraph{Modifier C}
Mit dem Modifier \texttt{C} wird eine Anweisung nur ausgeführt,
wenn der Akkumulator den Wert TRUE enthält.

\begin{verbatim}
LD    Var1
GT    10
JMPC  label
LD    20
ST    Var2
label:
\end{verbatim}

Ist \texttt{Var1 > 10}, wird der Sprung ausgeführt und
die Zuweisung an \texttt{Var2} übersprungen.

\subsubsection{Sprünge und Marken}

AWL unterstützt bedingte und unbedingte Sprünge.
Sprungziele werden durch Marken (Labels) definiert.

\begin{itemize}
    \item JMP  – unbedingter Sprung
    \item JMPC – bedingter Sprung (TRUE)
    \item JMPCN – bedingter Sprung (FALSE)
\end{itemize}

Sprünge ermöglichen einfache Ablaufsteuerungen,
ersetzen jedoch keine strukturierte Ablaufbeschreibung.

\begin{figure}[H]
    \centering
    \includegraphics[page=75,width=0.8\textwidth]{/Users/danielweindl/_source/Repositorys/STT-Lernskript/Data/sttvo-k03-Programmiersprachen-4v5-Folien.pdf}    
 \end{figure}


\subsubsection{Kommentare}

Kommentare dienen ausschließlich der Dokumentation
und haben keinen Einfluss auf die Programmausführung.

\begin{itemize}
    \item Mehrzeilige Kommentare: \texttt{(* Kommentar *)}
    \item Zeilenkommentare (herstellerspezifisch): \texttt{// Kommentar}
\end{itemize}

In AWL sind Kommentare besonders wichtig,
da die Lesbarkeit geringer ist als bei grafischen Sprachen.

\subsubsection{Variablendeklaration in AWL}

In der Anweisungsliste (AWL) werden Variablen
nicht implizit verwendet,
sondern müssen eindeutig deklariert
und adressiert werden.
Die Deklaration erfolgt abhängig vom Gültigkeitsbereich
und vom verwendeten Bausteintyp.

\paragraph{Grundprinzip}

AWL arbeitet adressorientiert.
Variablen werden entweder
\begin{itemize}
    \item symbolisch (über Symboltabelle)
    \item oder absolut (über Speicheradressen)
\end{itemize}
angesprochen.

Die eigentliche Variablendeklaration
erfolgt in den Schnittstellen von Bausteinen
oder in globalen Datenbereichen.

\paragraph{Deklaration in Bausteinschnittstellen}

In Funktionsbausteinen (FB) und Funktionen (FC)
werden Variablen in der Bausteinschnittstelle deklariert:

\begin{itemize}
    \item \textbf{VAR\_INPUT} – Eingangsvariablen
    \item \textbf{VAR\_OUTPUT} – Ausgangsvariablen
    \item \textbf{VAR\_IN\_OUT} – Ein-/Ausgangsvariablen
    \item \textbf{VAR} – statische lokale Variablen (nur FB)
    \item \textbf{VAR\_TEMP} – temporäre lokale Variablen
\end{itemize}

\paragraph{Beispiel: Bausteinschnittstelle}

\begin{verbatim}
VAR_INPUT
    Start : BOOL;
END_VAR

VAR_OUTPUT
    Motor : BOOL;
END_VAR

VAR
    Zustand : INT;
END_VAR
\end{verbatim}

\paragraph{Adressierung in AWL}

In AWL werden die deklarierten Variablen
über ihren Namen oder ihre Adresse verwendet.

Beispiele:
\begin{itemize}
    \item \texttt{E 0.0} – digitaler Eingang
    \item \texttt{A 0.0} – digitaler Ausgang
    \item \texttt{M 10.0} – Merkerbit
    \item \texttt{DB10.DBX 0.0} – Datenbaustein, Bit
\end{itemize}

\paragraph{Beispiel: Verwendung in AWL}

\begin{verbatim}
      U     Start
      =     Motor
\end{verbatim}

\paragraph{Globale Variablen}

Globale Variablen werden typischerweise
in Merkerbereichen oder Datenbausteinen abgelegt.
Sie sind von mehreren Bausteinen aus zugreifbar,
erhöhen jedoch die Kopplung des Programms.

\paragraph{Besonderheiten von AWL}

\begin{itemize}
    \item Keine automatische Typprüfung zur Laufzeit
    \item Hohe Nähe zur Hardware
    \item Klare Trennung zwischen Deklaration und Nutzung
\end{itemize}

\medskip
\textbf{Merksatz:}  
\emph{In AWL wird nicht „variablenorientiert“, sondern
adress- und bausteinorientiert programmiert.}

\subsubsection{Actions}
\begin{figure}[H]
    \centering
    \includegraphics[page=87,width=0.8\textwidth]{/Users/danielweindl/_source/Repositorys/STT-Lernskript/Data/sttvo-k03-Programmiersprachen-4v5-Folien.pdf}    
 \end{figure}


\subsubsection{Vor- und Nachteile von AWL}

\paragraph{Vorteile}
\begin{itemize}
    \item Maschinennah und effizient
    \item Gute Kontrolle über den Programmablauf
    \item Binäre Logik sehr einfach abbildbar
    \item Analogwertverarbeitung einfacher als in KOP
\end{itemize}

\paragraph{Nachteile}
\begin{itemize}
    \item Geringe Übersichtlichkeit
    \item Schleifen und Verzweigungen nur umständlich realisierbar
    \item Hoher Dokumentationsaufwand notwendig
\end{itemize}

\subsubsection{Einordnung}

AWL ist besonders geeignet für:
\begin{itemize}
    \item zeitkritische Programmteile
    \item maschinennahe Steuerungslogik
    \item Analyse und Optimierung bestehender Programme
\end{itemize}

In modernen Projekten wird AWL häufig durch ST oder grafische Sprachen ergänzt.
